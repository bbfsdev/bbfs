#!/usr/bin/env ruby

# Runs content server. This server monitors a set of directories (blobs/patterns).
# The files in those directories are indexed (calculating their SHA1).
# Each unique content is backed up to the remote (backup) server.

begin
  require 'yaml'
  require 'params'
  require 'run_in_background'
  require 'content_server'
rescue LoadError
  require 'rubygems'
  require 'yaml'
  require 'params'
  require 'run_in_background'
  require 'content_server'
end
include BBFS

#--------------------------
#  Parameters
begin
  Params.raise_error_if_param_exists  'content_server_background'
  Params.boolean 'content_server_background', false, 'Whether server should be run in background'
  Params.string 'content_server_command', 'start', 'Server\'s command. Commands are: start, delete'
  Params.string 'content_server_servicename', File.basename(__FILE__), 'Background service name'
  Params.string 'content_server_config',\
    File.join(Dir.home, '.bbfs', 'etc', 'config',\
              "#{Params['content_server_servicename']}.yml"),\
              'Path to server\'s config file'
  Params['content_server_config'] = File.expand_path Params['content_server_config']
rescue
  # parameters already defined <= running daemon now
end

#--------------------------
# Initialization
Params.init ARGV

if File.exists? Params['content_server_config']
  File.open(Params['content_server_config'], 'r') do |file|
    Params.read_yml_params file
  end
end
Params['log_param_number_of_mega_bytes_stored_before_flush'] = 0
Params['log_param_max_elapsed_time_in_seconds_from_last_flush'] = 0

#--------------------------
# Functions
def update_argv_with_config_file config_file_path
  if File.exists? Params['content_server_config']
    config = YAML.load_file config_file_path
    config.each do |key, value|
      # format taken from the commnad line parsing of Params
      # values are escaped for the case that they contain spaces
      value = %Q{"#{value}"} if value =~ / /
      ARGV.unshift ['--', key, '=', value].join 
    end
  end
end

# prepare ARGV so it can be provided as a command line arguments
def prepare_argv
  new_argv = Array.new
  ARGV.each do |arg|
    arg_arr = arg.split '='
    if arg_arr.size == 1
      arg = "\"#{arg}\"" if arg =~ / /
      new_argv << arg
    elsif arg_arr.size == 2
      arg_arr[1] = "\"#{arg_arr[1]}\"" if arg_arr[1] =~ / /
      new_argv << arg_arr.join('=')
    else
      Log::warning "ARGV argument #{arg} wasn't processed"
      new_argv << arg
    end
  end
  ARGV.clear
  ARGV.concat new_argv
end

#---------------------------
# Main
case Params['content_server_command']
when 'start'
  if Params['content_server_background']
    # to prevent service enter loop cause of background parameter
    # all options that points to run in background must be disabled
    # (for more information see documentation for RunInBackground::start!)
    Params['content_server_background'] = false    
    prepare_argv
    update_argv_with_config_file Params['content_server_config']
    
    ARGV.each do |arg| 
      if arg =~ /content_server_background/ && arg =~ /true/
        arg.sub! 'true', 'false'
      elsif arg =~ /content_server_config/
        arg.sub!(/=.*/) {|s| s='=should_be_undef'}
      end 
    end    
    begin
      RunInBackground.start! Params['content_server_servicename']
    rescue Exception => e
      Log.error "Start service command failed: #{e.message}"
      raise
    end
  else
    Log.info 'content_server started'
    ContentServer.run
  end
when 'delete'
  if RunInBackground.exists? Params['content_server_servicename']
    RunInBackground.delete Params['content_server_servicename']
  else
    msg = "Can't delete. Service #{Params['content_server_servicename']} already deleted"
    puts msg
    Log.warning msg
  end
else
  msg = "Unsupported command #{Params['content_server_command']}. Supported commands are: start, delete"
  puts msg
  Log.error msg
end

#let's log be written
sleep Params['log_param_max_elapsed_time_in_seconds_from_last_flush'] + 0.5

